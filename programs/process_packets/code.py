import board
from busio import UART


Packet_lengths_spaceorb = {
    'D': 13,
    'K': 6,
    '.': 4,
    'C': 4,
    'F': 4,
    'M': 5,
    'N': 4,
    'P': 6,
    '\v': 1,
    '\n': 1,
    '\r': 1,
    '@': 62,
    'E': 5,
    'Z': 14,
    'd': 26,
    'k': 5
    }


class Observable:

    def __init__(self):
        self.observers = []

    def attach(self, observer):
        self.observers.append(observer)

    def detach(self, observer):
        self.observers.remove(observer)

    def emit(self, msg):
        for observer in self.observers:
            observer.receive(msg)


class Observer:

    def __init__(self):
        pass

    def receive(self, msg):
        pass


class PipelineStage(Observable, Observer):

    def __init__(self):
        super().__init__()


class UARTSource(Observable):

    def __init__(self):
        super().__init__()
        self.uart = UART(board.TX, board.RX, baudrate=9600)

    def tick(self):
        self.emit(self.uart.read(self.uart.in_waiting))


class Packetizer(PipelineStage):

    def __init__(self, packet_lengths):
        super().__init__()
        self.packet_lengths = packet_lengths
        self.buf = bytearray(max(self.packet_lengths.values()))
        self.in_packet = False
        self.cursor = 0

    def current_packet_length(self):
        if self.in_packet:
            return self.packet_lengths.get(chr(self.buf[0]), 0)
        else:
            return 0

    def add_byte(self, b):
        if self.in_packet:
            self.buf[self.cursor] = b
            self.cursor = self.cursor + 1
        else:
            if chr(b) in self.packet_lengths:
                self.buf[0] = b
                self.cursor = 1
                self.in_packet = True
        if self.in_packet and self.cursor >= self.current_packet_length():
            self.emit(self.buf[0:self.cursor])
            self.in_packet = False
            self.cursor = 0

    def receive(self, bs):
        for b in bs:
            self.add_byte(b)


def process_spaceorb_buttondata(buf):
    """
    buffer[2] now has data in the form 1<rezero><F><E><D><C><B><A>
    """
    return dict(buttons=buf[2] & 63,
                reset=(buf[2] & 64) != 0)


def process_spaceorb_balldata(buf):
    """
    D<button status><D1><D2><D3><D4><D5><D6><D7><D8><D9><xor>
    from elsewhere:
    <D1> to <D9> are data bytes containing the force and torque components.
    These values are generated by first packing the six 10 bit values then
    xoring them with the characters "SpaceWare". Packed data has the form:
    1XXX XXXX 1XXX YYYY 1YYY YYYZ 1ZZZ ZZZZ1ZZx
    xxxx 1xxx xxyy 1yyy yyyy 1yzz zzzz1zzz z000
    where XXXXXXXXXX , YYYYYYYYYY , ZZZZZZZZZZ are the components of force.
    xxxxxxxxxx , yyyyyyyyyy , zzzzzzzzzz are the components of torque.
    ...
    Note the "at rest" packet, the packet with all force and torque
    components at zero, will contain the word "SpaceWare".
    """
    s = bytearray('SpaceWare')
    for i in range(9):
        buf[i+2] ^= s[i]

    # now process the button character
    buttons = buf[1] & 63

    # now process the ball components
    def mshl(b, mask, shift):
        return (int(b) & mask) << shift

    def mshr(b, mask, shift):
        return (int(b) & mask) >> shift

    def resign(i):
        # we have signed 10-bit integers; need to fix that
        schar = 0x0200
        smask = 0xfe00
        if (i & schar):
            return (i & (~schar))-512
        return i

    axes = [0]*6
    axes[0] = resign(mshl(buf[2], 0x7f, 3) | mshr(buf[3], 0x70, 4))
    axes[1] = resign(mshl(buf[3], 0x0f, 6) | mshr(buf[4], 0x7e, 1))
    axes[2] = resign(mshl(buf[4], 0x01, 9) | mshl(buf[5], 0x7f, 2))
    axes[3] = resign(mshl(buf[6], 0x1f, 5) | mshr(buf[7], 0x7c, 2))
    axes[4] = resign(mshl(buf[7], 0x03, 8) | mshl(buf[8], 0x7f, 1))
    axes[5] = resign(mshl(buf[9], 0x3f, 4) | mshr(buf[10], 0x78, 3))

    return dict(buttons=buttons, axes=axes)


Packet_processors_spaceorb = {
    'K': process_spaceorb_buttondata,
    'D': process_spaceorb_balldata
    }


class PacketProcessor(PipelineStage):

    def __init__(self, processors):
        super().__init__()
        self.processors = processors

    def receive(self, msg):
        packet_type = chr(msg[0])
        if packet_type in self.processors:
            self.emit(self.processors[packet_type](msg))


class StdOutObserver(Observer):

    def __init__(self, label):
        super().__init__()
        self.label = label

    def receive(self, msg):
        print(self.label, ": ", msg)


def connect_pipeline(stages):
    pairs = [(stages[i], stages[i+1]) for i in range(len(stages)-1)]
    for pair in pairs:
        pair[0].attach(pair[1])
    return stages


def main():
    pipeline = connect_pipeline([
        UARTSource(),
        Packetizer(Packet_lengths_spaceorb),
        PacketProcessor(Packet_processors_spaceorb),
        ])

    pipeline[1].attach(StdOutObserver("Packet"))
    pipeline[2].attach(StdOutObserver("Processed Packet"))

    while True:
        pipeline[0].tick()


if __name__ == "__main__":
    main()
